# 正则

## 什么是正则？

Python正则表达式，是一种基于字符串模式匹配的语法规则，其功能是在字符串中进行模式匹配和替换。

## 应用场景？

正则表达式通常用于处理文本数据，比如字符串的搜索、匹配、替换等。以下是一些常见的使用场景：

1、数据验证：正则表达式可以用于验证输入的数据是否符合规定的格式，比如验证电子邮件地址、手机号码、身份证号码等等。

2、数据清洗：在处理一些需要抽取特定信息的文本时，正则表达式可以用于清洗文本，去除不需要的字符或者格式，比如去除HTML标签、删除空格、统一格式等等。

3、数据抽取：正则表达式可以用于从文本中抽取出符合某种格式的信息，比如提取网页中的链接、抽取电子邮件地址等等。

4、数据转换：正则表达式可以用于将一种格式的文本转换为另一种格式，比如将日期格式转换为另一种日期格式、将金额转换为另一种货币符号等等。

5、代码开发：正则表达式可以用于代码开发中，比如根据指定的格式匹配某些字符串、对代码进行格式化等等。

## python正则？

re模块

## 固定的字符匹配

```python
# re 是Python内置提供的一个功能库，这个功能库可以帮助我们查找数据

# 1、导入
import re
text = "张三身高:178,体重:168,学号:123456,密码:1024"
# 从某个字符串中查找某个数据 .findall(要查找的内容,从哪里找)
# findall 是有多少个就查到多少个
res = re.findall("1",text)
print(res)
# missing 1 required positional argument: 'string'  原因是参数给少了

text = "身高:178,体重:168,学号:123456,密码:1024张三"
# 从字符串开头查找某个数据，只查找一次
# re.match(要查找的内容,从哪里找)    返回结果是一个对象
res = re.match("张三",text)
print(res)
# print(res.group())    # 查看查到的内容
# print(res.span())    # 查看下标

text = "张三身高:178,体重:168,学号:123456,密码:1024张三"
# 从整个字符串中查找某个数据，查找一次
# re.search()
res = re.search("张三",text)
print(res)
# print(res.group())
# print(res.span())

# 可以用于统计 某一个字符串在整个数据中出现的次数
```

## 某一类字符（单字符匹配）

```python
# 某一类字符
import re

text = '''[
{张三身高: 178, 体重: 168, 学号: 123456, 密码: 1024},
{李四身高: 188, 体重: 138, 学号: 123-456, 密码: 1024}
]'''

# 对暗号，电脑能够认识这些暗号，指定的暗号干指定的事情
'. 匹配除了 \n换行符 之前的其他任何内容'
# 实现：查找整个 text 字符串中 :后的数据    findall(匹配规则,数据源)
# :... 是告诉电脑，查找text字符串中所有以 :xxx 格式存在的数据
print(re.findall(":...", text))
print(re.findall(":(...)", text))   # 只要（）中匹配到的数据

# 从字符串中匹配，符合 [] 中内容的数据
print(re.findall('[张密四:]', text))

# 匹配所有数字
print(re.findall("\d", text))
# 匹配所有非数字
print(re.findall("\D", text))
# \D \d 联合使用，查找 三个非数字+两个数字 这样模式的数据
print(re.findall('\D\D\D\d\d\d', text))

# 匹配所有空格,以及换行
print(re.findall("\s", text))
# 匹配非空白
print(re.findall("\S", text))
# \S \s 结合使用
print(re.findall("\S\S\S\s", text))

# 匹配除了标点符号外具体的文本信息数据: 数字、字母、汉字...
print(re.findall("\w", text))
# 匹配符号
print(re.findall("\W", text))
# \W \w 结合使用   匹配 2个单词(单个字符)+1个符号 模式的数据
print(re.findall("\w\w\W", text))
```

## 重复某一类字符（数量元字符）

数量元字符 是用于修饰单个元字符的

```python
import re

text = '''[
{张三身高: 178, 体重: 16890, 学号: 123456, 密码: 1024},
{李四身高: 188, 体重: , 学号: 123-456, 密码: 1024}
]'''

# 数量元字符 是用于修饰单个元字符的
# \d* 匹配数字    学号: \d* 匹配学号: 后面的数字，这个数字可能是0个可能是多个
# 当你不确定我们要匹配的数据有几个的时候，可以用*
# * 最少可以一个数据都匹配不到
print(re.findall("学号: \d*", text))
print(re.findall("体重: \d*", text))   # (体重: )+(不知道几个数字)这样格式的数据

# + 修饰前一个字符，匹配1~无限次 (最少要有一个数据)
print(re.findall("体重: \d+",text))
# 数量元字符在进行练习的时候尽可能结合单个元字符匹配规则使用
print(re.findall("\D\D\W\d+",text))
# print(re.findall("\d+", text))    # 一般不会这么用
# print(re.findall("+", text))    # 不会这么用

# ？ 要不0次要么1次，修饰前一个字符
print(re.findall("学号: \d?", text))
print(re.findall("体重: \d?", text))
# 用了？ 就只差1次或者0次，即使我们有很多的数据，它也不会再查询了
# {}   限定具体的匹配次数
# {次数}    限定匹配多少次
# 匹配(学号: )+(除\n之外任意4个字符) 这样模式的数据
print(re.findall("学号: .{4}",text))
# {次数,}   限定匹配最少多少次
print(re.findall("体重: \d{1,}", text))
# {,次数}   限定匹配最多多少次
print(re.findall("学号: .{,4}",text))
# {次数,次数} 限定最少多少次，最多多少次
print(re.findall("体重: \d{1,3}",text))
```

## 组合某一类字符

```python
import re
# 包含了电话号码的字符串
text2 = '''[
            {姓名:张三, 电话: 18887654321, 幸运数:01234567891, 座机:0511-52152166}
            {姓名:李四, 电话: 18887654321, 幸运数:01234567891, 座机:0511-52152166}
        ]'''
# 1、确定要的数据是什么模式 数字-数字
# 2、这个模式需要那些元字符 \d
# 3、根据这个数字出现次数,确定修饰符 {} + * ？
# 4、写正则匹配规则
# 5、用代码去验证

# 需用使用以上讲到的所有匹配元字符，进行结合使用
# 0511-52152166  -整理成正则的格式->  \d{4}-\d{8}   【正则表达式】
print(re.findall("\d{4}-\d{8}", text2))

# 01234567891、18887654321 --> \d{11}
# 既可以匹配到 \d{11} 又可以匹配 \d{4}-\d{8}
# | 是或者的意思
print(re.findall("\d{11}|\d{4}-\d{8}", text2))	# 匹配 电话和座机
```

## 限定位置

```python
import re
text2 = '姓名:张三, 电话: 18887654321, 幸运数:01234567891, 座机:0511-52152166'
# 边界元字符
print(re.findall(r"^张三", text2))
print(re.findall(r"66$", text2))
# 匹配 张三 两个字旁边没有汉字、字母、数字啥的，是其他的字符
print(re.findall(r"\b张三\b", text2))
# 匹配 运 字旁边 ，不是其他的字符，是汉字，字母，数字啥的。
print(re.findall(r"\B运\B", text2))
```

## 如何写？

写正则表达式的步骤：
如何写正则表达式呢？我总结了几个步骤。不管多复杂，基本上都百试不爽。
我们仍然以包含分机号码的座机电话号码为例，比如0571-88776655-9527，演示下面的步骤：

- 确定模式包含几个子模式(确定数据格式)

它包含3个子模式：0571-88776655-9527。这3个子模式用固定字符连接。

- 各个部分的字符分类是什么(确定数据格式有需要那些元字符)

这3个子模式都是数字类型，可以用\d。现在可以写出模式为：\d-\d-\d

- 各个子模式如何重复（确定元字符的修饰次数）

第1个子模式重复3到4次，因为有010和021等直辖市
第2个子模式重复7到8次，有的地区只有7位电话号码
第3个子模式重复3-4次
加上次数限制后，模式成为：\d{3,4}-\d{7,8}-\d{3,4}

但有的座机没有分机号，所以我们用或运算符让它支持两者：
\d{3,4}-\d{7,8}-\d{3,4}|\d{3,4}-\d{7,8}

经过一通分析，最后的正则就写成了，测试一下：

```python
text3 = '随机电话：13634567891，座机1：0571-52152166，座机2：0571-52152188-1234'
"""
1,确定模式包含几个子模式
13634567891   11位数字
0571-52152166   3~4位数字-7~8位数字
0571-52152188-1234  3~4位数字-7~8位数字-3~4位数字

2,各个部分的字符分类是什么
\d  -

3,各个子模式如何重复

13634567891   11位数字   \d{11}
0571-52152166   3~4位数字-7~8位数字     \d{3,4}-\d{7,8}
0571-52152188-1234  3~4位数字-7~8位数字-3~4位数字       \d{3,4}-\d{7,8}-\d{4}
"""
print(re.findall(r"\d{11}|\d{3,4}-\d{7,8}|\d{3,4}-\d{7,8}-\d{4}", text3))

```