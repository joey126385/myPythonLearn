# 代码笔记

【若是出现纰漏的地方请私信老师~】

## 作用域

```python
# 变量 具有作用域（可以使用的范围）
x = 10    # 这是一个全局变量
def func1():
    b = 20    # 这是一个局部变量
```

局部变量可以与全局变量同名，他们两的生命空间不一致，且在电脑内部的保存地址也不一致

```python
x = 30
def func1():
    x = 30    # 创建一个局部变量
```

访问全局变量x的值:

```python
x = 10   # 这是一个全局变量
def func1():
    print(x)  # 访问全局变量x的值
func1()   # 调用我自己定义的函数
```

修改全局变量 x 的值:

**`global` 关键字 声明改动全局变量**

```python
x = 10   # 这是一个全局变量
def func1():
    global x      # 告诉python我们要修改全局变量x,而不是创建一个同名的局部变量
    x = x + 1	  # 修改全局变量 x 的值
func1()   # 调用我自己定义的函数

    # 全局变量可以在函数中被访问，但是在修改的时候，python会认为，我们是需要在局部再次创建一个同名的局部变量
    # 不加global会报这个错：local variable 'x' referenced before assignment
```

函数嵌套，内层函数访问外层函数局部变量

```python
# 函数嵌套
def func3():
    x = 666    # 声明一个局部变量 x 里面保存的值是 666
    # 创建内层函数
    def func4():
        print(x)   # 在函数内部访问 外层函数 局部变量 x 的值
    func4()
```

函数嵌套，内层函数修改外层函数局部变量

**`nonlocal` 关键字 声明改动局部变量**

```python
# 函数嵌套
def func3():
    # 声明一个局部变量 x 里面保存的值是 666
    x = 666
    # 创建内层函数
    def func4():
        nonlocal x
        x = x + 1      # 在局部修改x的值，电脑会认为我们是新创建了一个局部变量x
        print(x)
    func4()
    # 局部变量可以在嵌套函数（其他局部）中被访问，但是在修改的时候，python会认为，我们是需要在嵌套函数（其他局部）中再次创建一个同名的局部变量
    # 不加nonlocal会报这个错：local variable 'x' referenced before assignment
```

**id() 函数用于查看数据内存地址**

```python
# 别的语言，比如c++ 或者 java 先创建变量,再存数据（即：先在电脑当中开辟一段用于存放数据的空间）
# python中是先有这个数据，数据有了之后，再赋值到变量，这个赋值到变量其实可以理解为，给数据指一个名字，方便使用（即变量名是数据的引用）
a = 10
print(id(a))  # 查看a代表的这个数据10的空间
a = 20     #  a所代表的空是不是会发生改变?
print(id(a))	# 查看a代表的这个数据10的空间,发现地址果然有改变~
```

## 匿名函数

lambda表达式，通常是在需要一个函数，但是又不想费神去命名一个函数的场合下使用，也就是指匿名函数。

语法 ：

```
lambda 参数：表达式
```

案例：

```python
# 正常函数写法
def func6(x):
    print(f"我是{x}")
    return f"我是{x}"
# 打印func6的调用结果
print(func6(666))

# lambda 函数  它是正常函数的简写方式
func7 = lambda x : f"我是{x}"
# 打印func7的调用结果
print(func7(666))
```

一般情况下不会用lambda ,除非是需用将函数作为参数传递的时候，才使用的比较多。

## 回调函数

​        有一家旅馆提供叫醒服务，但是要求旅客自己决定叫醒的方法。可以是打客房电话，也可以是派服务员去敲门，睡得死怕耽误事的，还可以要求往自己头上浇盆水。这里，“叫醒”这个行为是旅馆提供的，相当于库函数，但是叫醒的方式是由旅客决定并告诉旅馆的，也就是回调函数。而旅客告诉旅馆怎么叫醒自己的动作，也就是把回调函数传入库函数的动作，称为登记回调函数

**概念：将函数作为参数传递**

```python
# 酒店提供叫醒服务，但是叫醒的方式由客户自己去决定
def jiaoXing(fangShi,name):
    f = fangShi(name)  # 调用回调函数
    print(f)

# 调用叫醒服务函数，传了一个叫醒方式的回调函数，并且传了被叫醒对象变量值
jiaoXing(lambda name : f"打电话叫醒{name}","张三")
jiaoXing(lambda mingZi : f"敲门叫醒{mingZi}","李四")
jiaoXing(lambda name : f"翻窗叫醒{name}","王五")
```

## 闭包：是一种现象

当两个函数嵌套的时候，外层函数返回内层函数的引用，这个叫做闭包

```python
# 什么引用？
a = 10   # a 是 数字10 的引用
```

```python
#  这种现象叫闭包：
def func10():     # 外层函数
    def func11():     # 内层函数
        print("我是func11")
    return func11        # 返回内层函数的引用
```

```python
# 闭包调用
new_func = func10()  #调用func10函数，得到func11函数引用
new_func()  # 调用func11函数引用
func10()()   # 简写，调用func10函数返回的函数
```

理解 - 用西游记中的某个法器举例：

```
func10 是一个荷包法器
func11是荷包当中非常重要的法器
new_func = func10() 是使用荷包法器,之后拿到了荷包当中的func11法器，并给这个法器重新取了个名字
new_func() 使用法器(即使用func11)
```

理解案例：

```python
# 以下函数的定义是去制作一个法器，法器名字func666代表这个法器
def func666():
    print("666")

# 查看func666名字对应的法器
print(func666)  # 查看函数func666的引用地址
# 控制台打印 <function func666 at 0x00000254A24F0A60>   func666函数在电脑的...位置

# 召唤法器然后使用
func666() #调用函数func666
```

## 函数递归【拓展内容】

概念： 函数递归就是自己调用自己
重点： 递归一定要有程序出口（一定要有一个程序会停下来的因素） 

```python
# 阶乘： 从1开始乘到自己本身
# 假设有3阶，它的阶乘： 1*2*3=6
# 假设有4阶，它的阶乘： 1*2*3*4=24

#  n 是阶数   func999 是计算阶乘的函数
def func999(n):
    if n == 0:
        return 1     #程序出口，最后一次递归 返回1
    else:
        return n * func999(n-1)
# 调用阶乘函数
x = func999(4)
print(x)
```

#### debug 错误调试

1、打断点
2、右键debug
3、点击调试台的小箭头（向下的）

```python
# 阶乘函数调用解析：
n=4 => func999(n) 
=> func999(4) => n*func999(n-1) =>4*func999(4-1) =>4*func999(3) => 4*6=24
# 第一次递归
n=3 => 
func999(3) => 3*func999(3-1) => 3*func999(2) => 3*2 = 6
# 第二次递归
n=2 =>
func999(2) => 2*func999(2-1) => 2*func999(1) => 2*1 =2
# 第三次递归
n=1 =>
func999(1) => 1* func999(1-1) => 1*func999(0) => 1*1 =1 
# 第四次递归
n=0 => func999(0) => 1

# 总结：
func999(0) = 1 
func999(1) = 1*1 =1
func999(2) = 2*1 =2
func999(3) = 3*2 =6
func999(4) = 4*6 =24
```

