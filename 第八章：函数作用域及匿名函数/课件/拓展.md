# 解答拓展课

## 回调函数

​        有一家旅馆提供叫醒服务，但是要求旅客自己决定叫醒的方法。可以是打客房电话，也可以是派服务员去敲门，睡得死怕耽误事的，还可以要求往自己头上浇盆水。这里，“叫醒”这个行为是旅馆提供的，相当于库函数，但是叫醒的方式是由旅客决定并告诉旅馆的，也就是回调函数。而旅客告诉旅馆怎么叫醒自己的动作，也就是把回调函数传入库函数的动作，称为登记回调函数

**概念：将函数作为参数传递**

```python
# 酒店提供叫醒服务，但是叫醒的方式由客户自己去决定
def jiaoXing(fangShi,name):
    f = fangShi(name)  # 调用回调函数
    print(f)

# 调用叫醒服务函数，传了一个叫醒方式的回调函数，并且传了被叫醒对象变量值
jiaoXing(lambda name : f"打电话叫醒{name}","张三")
jiaoXing(lambda mingZi : f"敲门叫醒{mingZi}","李四")
jiaoXing(lambda name : f"翻窗叫醒{name}","王五")
```

**回调机制的优势**

回调机制提供了非常大的灵活性。有的同学可定想回调似乎只是函数间的调用，可以发现两者之间的一个关键的不同：

在回调中，我们利用某种方式，把回调函数像参数一样传入中间函数。可以这么理解，在传入一个回调函数之前，中间函数是不完整的。换句话说，程序可以在运行时，通过登记不同的回调函数，来决定、改变中间函数的行为。这就比简单的函数调用要灵活太多了。

```Python
# 回调函数1
# 生成一个2*形式的偶数
def double(x):
    return x * 2

# 回调函数2
# 生成一个4*形式的偶数
def quadruple(x):
    return x * 4

# 中间函数
# 接受一个生成偶数的函数作为参数
# 返回一个奇数
def getOddNumber(k, getEvenNumber):
    return 1 + getEvenNumber(k)


# 起始函数，这里是程序的主函数
def main():
    k = 1
    # 当需要生成一个2k+1形式的奇数时
    i = getOddNumber(k, double)
    print(i)
    # 当需要一个4k+1形式的奇数时
    i = getOddNumber(k, quadruple)
    print(i)
    # 当需要一个8k+1形式的奇数时
    i = getOddNumber(k, lambda x: x * 8)
    print(i)

main()
```



## 闭包：是一种现象

当两个函数嵌套的时候，外层函数返回内层函数的引用，这个叫做闭包

```python
# 什么引用？
a = 10   # a 是 数字10 的引用
```

```python
#  这种现象叫闭包：
def func10():     # 外层函数
    def func11():     # 内层函数
        print("我是func11")
    return func11        # 返回内层函数的引用
```

```python
# 闭包调用
new_func = func10()  #调用func10函数，得到func11函数引用
new_func()  # 调用func11函数引用
func10()()   # 简写，调用func10函数返回的函数
```

理解 - 用西游记中的某个法器举例：

```
func10 是一个荷包法器
func11是荷包当中非常重要的法器
new_func = func10() 是使用荷包法器,之后拿到了荷包当中的func11法器，并给这个法器重新取了个名字
new_func() 使用法器(即使用func11)
```

理解案例：

```python
# 以下函数的定义是去制作一个法器，法器名字func666代表这个法器
def func666():
    print("666")

# 查看func666名字对应的法器
print(func666)  # 查看函数func666的引用地址
# 控制台打印 <function func666 at 0x00000254A24F0A60>   func666函数在电脑的...位置

# 召唤法器然后使用
func666() #调用函数func666
```



## 函数递归

概念： 函数递归就是自己调用自己
重点： 递归一定要有程序出口（一定要有一个程序会停下来的因素） 

```python
# 阶乘： 从1开始乘到自己本身
# 假设有3阶，它的阶乘： 1*2*3=6
# 假设有4阶，它的阶乘： 1*2*3*4=24

#  n 是阶数   func999 是计算阶乘的函数
def func999(n):
    if n == 0:
        return 1     #程序出口，最后一次递归 返回1
    else:
        return n * func999(n-1)
# 调用阶乘函数
x = func999(4)
print(x)
```

#### debug 错误调试

1、打断点
2、右键debug
3、点击调试台的小箭头（向下的）

```python
# 阶乘函数调用解析：
n=4 => func999(n) 
=> func999(4) => n*func999(n-1) =>4*func999(4-1) =>4*func999(3) => 4*6=24
# 第一次递归
n=3 => 
func999(3) => 3*func999(3-1) => 3*func999(2) => 3*2 = 6
# 第二次递归
n=2 =>
func999(2) => 2*func999(2-1) => 2*func999(1) => 2*1 =2
# 第三次递归
n=1 =>
func999(1) => 1* func999(1-1) => 1*func999(0) => 1*1 =1 
# 第四次递归
n=0 => func999(0) => 1

# 总结：
func999(0) = 1 
func999(1) = 1*1 =1
func999(2) = 2*1 =2
func999(3) = 3*2 =6
func999(4) = 4*6 =24
```



**斐波那契数列**兔子繁殖问题：

在700多年前，意大利著名数学家斐波那契在《算盘全集》中提到这样一个问题：一对兔子，从出生后第3个月起每个月都生一对兔子。小兔子长到第3个月后每个月又生一对兔子。假如兔子都不死，请问第1个月出生的一对兔子，第n个月有多少对兔子？

F(1)=1

F(2)=1

F(3)=F(1)+F(2)=1+1=2

F(4)=F(2)+F(3)

…………

F(N)=F(N-2)+F(N-1)

 

代码

```python
def fab(n):
    if n <= 2:
        return 1
    else:
        return fab(n - 1) + fab(n - 2)
n = eval(input())
print(fab(n))
```