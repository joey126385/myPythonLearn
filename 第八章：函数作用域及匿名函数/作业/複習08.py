"""
?A:函數調用
    一、函數(function)：有特定功能的代碼
    二、模塊(pythonFile):有函數的py文件
    三、包(package)：裡面有多個.py文件的文件夾+__init__.py文件的文件夾
!       1.__init__.py:文件本身沒有意義，主要放入此文件會讓python知道
        2.Python自帶的:python 內置包
        3.手動下載:python第三方包
        4.自己製作:原創包
        5. improt
    四、
    五、
    六、調用同級目錄下，包中的模塊中的函數
        from [python 包名稱]  import [python檔案]
?B:全局變量與局部變量
    一、作用域:
        1.全局變量：整個程序中都可見。
        2.局部變量：僅在其函數或代碼快內可見。
    二、生命週期:
        1.全局變數：生命週期從程序開始運行開始，直到程序結束。
        2.局部變數：生命週期僅在其被聲明的函數或代碼快執行期間存在。
    三、內存位置:   全局和局部有相同的名稱，但實際上存儲在不同的內存位置
        1.全局變數：在程序的整個生命週期中保持不變。
        2.局部變數：都會在內存中重新建立。
  ! 四、global:聲明改動全局變量
    五、nonlocal:聲明改動局部變數
?C:匿名函數 (lambda)
    一、語法：lambda 參數:表達式【lambda 名稱: 內容】
    二、匿名函式的特性:
        1.匿名函式{不需要定義名稱}，一般函式需定義名稱。
        2.匿名函式只能有一行運算式，一般函式可以有多航運算式。
        3.匿名函式執行完成後自動回傳結果，一般函式加上return 關鍵字才能回傳結果。
    三、如何搭配 lambda 
        1.使用多個參數
        2.搭配 for 迴圈
        3.搭配 if 迴圈
        4.搭配 map 迴圈
        5.搭配 filter 迴圈
        6.搭配 sorted 迴圈
?D:回調函數
    一、回調函數概念:將函數作為參數傳遞(這裡傳遞的是函數的引用)
    二、異步處理:
        回調機制非常適合處理異步事件，如網路請求、文件讀寫或用戶輸入等。
    三、代碼解耦:
        通過回調，可以將功能劃分為更小的、獨立的單元。
        每個單元可以專注於完成特定的任務，
    四、靈活性:
        回調函數可以作為參數傳遞給其他函數，這使得在運行時動態改變成為可能。
        例如:可以根據不同的條件或輸入傳遞不同的回調函數，以實現不同的功能。    
?E:閉包 (closure)
    一、什麼是閉包:
        閉包可以保存在函式作用範圍內的狀態，不會受到其他函示的影響，
        且無法從其他函式取得閉包內的資料，
!       也可以避免建立許多全域變數互相干擾。
    二、閉包定義:
        【A函式】中定義了【B函式】。
        【B函式】使用了【A函式】的變數。
        【A函式】回傳了【B函式】。       

"""

#!  A:函數調用
def a2():
    import testA
    testA.func();
a2();
# 調用同級目錄下，包中的模塊中的函數
def a3():
    from 福利代码 import 代码雨;
    代码雨.run();
a3();
#!  B:全局變量與局部變量
"""
*練習1:變量 具有作用域，請思考以下代碼中的變量分別是什麼作用域變量??
*練習2: 如果我們希望能夠在函數中區十項對全局變量進行改變該如何???
        global:聲明改動全局變量
*練習3:函數嵌套
        nonlocal:聲明改動局部變數

"""
x1=10;# 全局變數
x2=10;# 全局變數
def B_練習1():
    global x2;#　聲明改動，全局變數
    x1=30; # 局部變數
    x2=30; # 局部變數
    y1=20; # 局部變數
B_練習1();
print(f"全局變數\t:{x1}",f"全局變數\t:{x2}");# 因為局部

def B_練習3():
    x=2;
    y=10;
    def func2():
        nonlocal y;#　聲明改動局部變數
        x=200;
        y=100;
        print(f"在fun2 中查看 X 的值:{x}",f"\t在fun2 中查看 y 的值:{y}");
    func2()
    print(f"\n在B_練習3 中查看 X 的值:{x}",f"\t在fun2 中查看 y 的值:{y}");
B_練習3();

print("------------------");

#!  C:匿名函數
# 使用匿明函式 lambda
def c1 (title):
    print(title);
c1('爛打ss');
(lambda title:print(title))('爛打');
# 使用多個參數
def c2(x,y):
    return x+y;
print(f"一般函式寫法{c2(3,9)}");
print(f"使用lambda方式{(lambda x,y:x+y)(1,5)}");
# 搭配 for 迴圈
def c3 (n):
    a=list(range(n));
    return a;
print(f"一般函式{c3(3)}");
print(f"使用lamdba方式{(lambda n :[i for i in range(n)])(5)}");
# 搭配 if 判斷式
print(f"使用lamdba 搭配if判斷式{(lambda n: True if n<10 else False)(9)}");
#　搭配　map 
ca = [1,2,3,4,5,6,7,8,9];
print("使用lamdba 搭配map",list( map(lambda x: x*x, ca)));
# 搭配 filter
print(f"使用 lamdba 搭配 filter {list(filter (lambda x:x>5,ca))}");

def func6(x,y):
    return x+y;
print(func6(1,1)) ;
f888 = lambda x,y : x+y;
y = f888(3,3)
print(y)

print("--------------------------------------");
#!  D:回調函數
#   回调函数概念：将函数作为参数传递
def d1(param):# 傳入參數
    print(f"回調函數 d1() 值為{param}");# 調用傳入參數
d1('回調函數難不難!!');

print("--------------------------------------");
#!  E:閉包
def e1(msg):
    i='!!!';#　【閉包開始】
    def e11():# e1函式內定義了e11函式
        print(f"msg {msg}  i {i}");#　e11函式使用了e1函式的變數
    return e11;# 將e11函式當作回傳值【閉包結束】
s=e1('閉包');
s();
e1('閉包')();

#每次執行時保留下一個作用域的繫結關係
def e2():                       # 建立一個函式
    a=[];                       # 函式內有區域驗數a是串列  
    b=1;
    def e2_1(val):              # 建立內置函式 e21 (閉包)                      
        a.append(val);          # 將參數數值加入變數 a
        nonlocal b  ;           # 宣告B 變數是【自由變數】
        b+=val;
        print(a);               # 列印 a
        return sum(a)/len(a);   # 回傳 a 串列所有數值的平均
    return e2_1;                 # 回傳 e21
e2_test=e2();
e2_test(10);
e2_test(11);
x=e2_test(12);
print(x);



