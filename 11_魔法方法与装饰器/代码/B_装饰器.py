
"""
装饰器
装饰器其实也是一个闭包，其功能就是在不改动目标函数的同时，增加额外的功能。

闭包(是函数特殊的书写状态):
     1、两个函数嵌套
     2、外层函数返回内层函数名（函数引用）
"""

"""

# 闭包优势：
# 1、能够保护数据不被随意修改
# 2、闭包这样的写法可以延长 局部变量数据 的使用寿命
# 3、闭包可以用作装饰器

# 以下闭包展示了保护数据以及延长具备变量使用寿命的功能
def fucn1():
    def func2():      # 保存账户信息，并返回
        # 保存了账号信息
        userName = "buyu"
        userPass = 1024
        return userName,userPass    # 同时返回账号名与账户密码
    return func2
# 测试
f = fucn1()     # 直接调用闭包外层函数后返回的是：闭包的内存函数，即func2
print(f"直接调用闭包外层函数后返回的是：{f}")
x = f()     # 调用刚刚返回的 闭包的内存函数，即func2
print(x)    # ('buyu', 1024)
# 简化测试代码
x = fucn1()()
print(x)

u = "张三",1024     # python中规定了，当两个值用,连接，同时保存在一个变量中时，会自动保存为元组类型
print(u)

"""


"""
禁言功能 1.0版本已经上线了,现在客户觉得不满意，它觉得这个禁言功能太简陋了，希望能够有一些提示。
新需求： 
    升级 2.0版本，在禁言之前进行提示"开始禁言！"，并进行禁言倒计时，禁言结束后，提示"禁言结束~"。
思考：
    由于 禁言1.0版本函数 在上线的项目里面被使用了,所以目前我们遇到了一个难题。
    怎么样在尽可能少的改变 已经上线的项目原始代码的情况下，实现客户的需求？
"""
# 写前须知: 1.0函数，与1.0函数调用代码，由于已经上线，因此这几行代码不能改动，但是我们又需要在之前的效果上增加功能。

# 写一个用于作为装饰器的闭包【要有一个形参，用于接收要升级的函数（即禁言1.0函数） 】
def f1(f):
    def f2():    # 【而内层函数，用于实现具体的功能升级代码】
        print("-------------------开始禁言！")
        # f()       # 由于刚刚在写外层函数的时候，规划好了f是用于接受禁言1.0函数的，所以这里直接调用
        # 用循环模拟倒计时功能
        for i in range(8,0,-1):      # 该循环会循环8次，从8循环到1
            print(f"~~~~~~~~~~禁言倒计时{i}秒")
        print("-------------------禁言结束~")
    return f2

# 模拟游戏禁言的函数 禁言1.0版本
@f1
def banned_to_post():
    print("正在禁言中")

# 模拟在游戏中以及使用该1.0功能
banned_to_post()

# 什么是装饰器？
# 当某些情况，我们希望不改动源函数与源函数调用的基础上，增加源函数的功能，那这个时候可以按照固定的格式写一个闭包，
# 然后通过一个关键的@在需要升级的函数上，将这个闭包作为装饰器使用

# 测试一下，这个作为装饰器的闭包能不能实现2.0功能
# ff2 = f1(banned_to_post)      # 调用装饰器的外层函数，得到返回的值，即得到实现具体功能的内存函数
# ff2()

# 写装饰器步骤：
# 1、确定要升级的函数
# 2、写一个闭包,在外层函数中，要有一个形参，用于接收要升级的函数 ,而内层函数，用于实现具体的功能升级代码
# 3、在需要升级的函数前面，加上 @装饰器名字




