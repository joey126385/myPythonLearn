
# 什么是装饰器？
# 当某些情况，我们希望不改动源函数与源函数调用的基础上，增加源函数的功能，那这个时候可以按照固定的格式写一个闭包，
# 然后通过一个关键的@在需要升级的函数上，将这个闭包作为装饰器使用

# 写装饰器步骤：
# 1、确定要升级的函数
# 2、写一个闭包,在外层函数中，要有一个形参，用于接收要升级的函数 ,而内层函数，用于实现具体的功能升级代码
# 3、在需要升级的函数前面，加上 @装饰器名字

# 2.1、写一个闭包
def sleep_2(x):     # 2.2、在外层函数中，要有一个形参x，我们规划x用于接收要升级的函数（即sleep函数）
    def gong_neng():      # 2.3、而内层函数，用于实现具体的功能升级代码
        x()    # 调用x【解说：由于x设计是用来接受要升级的函数（即sleep函数），所以这里调用x的效果是，打印"睡眠中！"】
        print("睡眠时间8小时！")
    return gong_neng     # 闭包固定写法：返回内层函数引用
# --------------------------以上为装饰器的闭包就写好了，但是他目前还不是一个完整的装饰器

# 这个是1.0版本的睡眠功能
@sleep_2
def sleep():
    print("睡眠中！")

# 现在1.0版本睡眠功能已经被使用
sleep()

# 需求： 需要在不改动上方代码的基础上，增加功能，在控制台打印一句，"睡眠时间8小时！"

# 注意：在往后的学习过程中，我们并不需要自己写装饰器的闭包代码，后期只要用就行，但是在基础班阶段，我们得去了解一下闭包是怎么实现的.

# print("------------------------分割线---------------------------")
# 测试，用于作为装饰器的这个闭包sleep_2，是不是已经实现需求要增加的功能
# g = sleep_2(sleep)      # 调用闭包sleep_2，由于这个闭包在创建的时候，我们就规划好了参数，因此，这里填 sleep
# 由于sleep_2是一个闭包，因此，调用之后的返回值是一个函数，相当于 g 里面存了一个函数
# g()     # 调用函数【回顾：函数调用的固定语法是 函数名()】
# print("------------------------分割线---------------------------")
