"""
思考:
手机需要出新版本(新增功能) , 如果你是设计师,你会如何选择?
1.每一代新款手机,都从0开始出设计图 (从头写一个新的类)
2,基于老款的设计图,修修改改. (基于已有的Phone类代码进行修改)

"""
# 【父亲】设计手机模版，这个类是设计图纸 1.0   只能打电话
class Phone():
    # 在创建手机实例的时候，初始化手机对象
    def __init__(self, brand, price):
        self.brand = brand
        self.price = price
    # 模拟拨打电话，将被拨打的电话号码作为参数传递给该方法
    def make_call(self, phone_number):
        print(f"正在给号码为{phone_number}的机主打电话")

# 【儿子】手机模版 2.0   加了一个发短信的功能
class Phone_plus(Phone):       # 创建一个升级版的手机类，然后声明继承1.0版本手机类的功能
    # 为了去测试2.0是否继承了1.0,所以这个类中暂时不写代码,但是不写代码Python会觉得这个类语法不完整，所以可以使用pass补全语法
    # pass
    # 创建一个模拟生活中发短信的方法
    def send_msg(self,phone_number,msg):
        print(f"正在给号码为{phone_number}的机主，发送信息：{msg}")

# # 根据2.0创建一个对象
# x1 = Phone_plus("小米","3999")
# # 测试，2.0版本的对象，能不能使用1.0版本的功能
# x1.make_call("110")
# # 测试 2.0版本新功能
# x1.send_msg("110","救救我！")

# 【儿子的儿子 = 孙子 】手机模版 3.0   加了一个NFC刷卡
class P_plus_plus(Phone_plus):
    # pass   # 是用于补全语法，不报错的，这里我要先不写任何东西，去测试 3.0 是否具有 1.0 与 2.0 的功能
    def nfc(self):
        print("滴~正在使用NFC刷卡！")

# 创建一个3.0手机对象
o1 = P_plus_plus("oppo","3988")
# 测试是否具备 2.0功能
o1.send_msg("10086","今天天气真好！")
# 测试是否具备 1.0功能
o1.make_call("10086")
# 总结：继承具有传递性。
# 测试，新增的3.0新功能，是否能够使用
o1.nfc()

"""
一、什么是继承？
    当我们有一个基础版的类之后，如果说我需要使用这个类，基于它去进行升级，那么可以使用继承的概念。
    这个继承概念是在编程里面的一种实现方式，类似于生活中，复制一份新手机设计图纸，再复制版的基础上继续修改。
	从父类中继承(复制)来成员变量和成员方法(不含私有)。

二、继承的语法？

单继承：
class 类名(父类名):
    类代码块
    
多继承：
class 类名(父类1,父类2):
    类代码块

"""
